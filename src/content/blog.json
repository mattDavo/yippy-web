[
    {
        "id": 0,
        "title": "First Post!",
        "content": "Goals for working on Yippy:\n- Learn and use reactive programming\n- Use test driven development\n- Learn macOS development\n- Put out releases and act based on feedback\n- Build a great tool/app!\n- Learn the use of functional programming in a Swift + macOS environment",
        "date": 1565097487,
        "author": "Matt Davidson"
    },
    {
        "id": 1,
        "title": "Challenges with RxSwift",
        "content": "As a part of my learning experience in developing Yippy I have decided to learn reactive programming. As Yippy is being developed in Swift, I have chosen to use <code>RxSwift</code>. So I have started trying to implement the reactive programming patterns to Yippy. So far I have found it to be more difficult than I anticipated but I can tell that it is starting to make sense, and how I'm supposed to use and implement. I think it will continue to be a large learning curve but worthwhile.",
        "date": 1566882327,
        "author": "Matt Davidson"
    },
    {
        "id": 2,
        "title": "Improving the User Experience",
        "content": "To get users to test and receive helpful feedback I decided that I needed to improve the installation experience, as it wasn't clear why or how the user should provide full control to Yippy. Unfortunately due to macOSX this clunky step is necessary, so I need to try and make it as seemless for the user as possible. So I have added a step to prompt the user into providing the full control. Additionally I have added a help window that provides instructions on how to use Yippy once full control is given, until then the user is prompted to provide full access. Hopefully these steps will be enough in the short term to make the installation process simple.\n\nNow that I have added a fair amount of code complexity to the app, I have to dedicate some time to cleaning up the app. This will involve removing all warnings, making the code more readable, converting more code to use <code>RxSwift</code> and importantly write tests! I haven't done much testing, UI or otherwise in Swift so this will be a good opportunity to learn how the Xcode testing framework works. I think this is an important next step, so as I add more features to Yippy I can be sure that the original and future features work as expected.",
        "date": 1568347088,
        "author": "Matt Davidson"
    },
    {
        "id": 3,
        "title": "Wrangling with NSEvent monitoring",
        "content": "Unfortunately I wasted a lot of time trying to rewrite the key events to control the Yippy history window. After many hours and almost getting a much cleaner rewrite to work I discovered that I can’t use <code>NSEvent.addGlobalMonitorForEvents</code> and/or <code>NSEvent.addLocalMonitorForEvents</code> the way I want to due to the nature of the API and Yippy being an agent-only application. I originally had this working using the HotKey <insert link> library but did not like some of the unclean code I was using to turn it off and on again. However, it seems that I may have to use it, or write my own module which uses the (quite confusing) Carbon API like HotKey. It may just be best to use the HotKey library.\n\nHowever, I have managed to write some nice and useful code which could be re-used in future projects (that are not agent-only), so I may finish it off and put it into a separate repo.",
        "date": 1569051098,
        "author": "Matt Davidson"
    },
    {
        "id": 4,
        "title": "Not a total waste of time",
        "content": "I decided to try a few more things and was able to get it to work closer to how I imagined by forcing the app to activate and then returning the focus to the previous application. However this ended up making the code more confusing, and it removed some of the convenient functionality that I originally had using <code>HotKey</code>.\n\nHowever this is not all bad as I will be able to use it in other parts of the app where the window should be active.",
        "date": 1569137508,
        "author": "Matt Davidson"
    },
    {
        "id": 5,
        "title": "The Testing Experience",
        "content": "I’ve now cleaned the app up a lot by moving a lot of code into models, so that the controllers (and the app delegate) are not doing all of the work. There is still some more work to be done on this, really just for the Yippy history window and managing of the history state and any changes.\n\nHowever, this has been some good work and I have been able to start writing tests, learning how Xcode’s testing framework works. There are two components to Xcode’s testing framework: the unit testing side and the UI testing side. I decided to start with the unit tests as I thought it made the most sense. I’ve made a start by testing the basic stuff, such as the <code>Settings</code> structure, simple methods in my Cocoa extensions, my wrapper around <a href=\"https://github.com/soffes/HotKey\" target=\"_blank\">HotKey</a> and my pasteboard monitor which essentially make the up the core of Yippy. Yippy doesn’t actually have a very intensive user interface, it is mainly a lot of different event handling to provide the user an up-to-date record of their pasteboard and quick way for them to access it. This has really fit into this reactive style of programming.\n\nStarting with the unit testing framework, I started to get a better understanding of how I would do the testing and I also got a taste of the trickiness of how the UI testing would be for me. For the basic models, writing tests was easy, just using the <b>\"given, when, then\"</b> style of writing tests. However, for testing my <code>Settings</code> structure which persistently stores objects in the standard <code>UserDefaults</code> it would be a bit harder. Firstly, to prevent any flakiness we need the testing environment the same every time and secondly to avoid messing with my own installation of Yippy the tests should interact with their own user defaults. However, due to the way I’ve set up my <code>Settings</code> structure this would prove more difficult because the unit testing framework runs the tests with the same bundle identifier. This led me <a href=\"http://www.figure.ink/blog/2016/10/15/testing-userdefaults\" target=\"_blank\">this</a> blog post which allowed me to write my own functions to run tests under a clean environment every time, preserving my own Yippy settings.\n\nAs I moved to the UI testing, I slowly discovered how much harder it would be to run UI tests in a perfectly defined environment. This is because in the UITests the bundle identifier of the code in the tests is different to the bundle identifier of the instance of the app running (which makes sense). However, this means we don’t have the luxury of blanking persistent structures (like my <code>Settings</code>) within the tests. We have to provide launch arguments to the app and within our app detect these arguments and set up the state accordingly. This doesn’t sound too hard right? Well, sort of... It’s not too difficult define our own state for things such as the settings, on launch save the original settings, load the test ones and on termination restore the original settings.\n\nHowever, it is more difficult to concoct and simulate a state where it’s defined by the system. In Yippy, we require the user to provide full access, which in Swift can be checked if we have it by calling <code>AXIsProcessTrusted()</code>. But I need to be able to test when this returns different values and I shouldn’t have to manually change the access of my computer as I run the tests, that just makes them flaky. So I wrote some wrapper functions, that can be mocked out when the app runs in a UI test. Now that’s all pretty simple but parts of Yippy actually probes this function waiting for a change and I need to be able to test that… That’s not quite as simple. The test needs to run without the access, then at a certain point in the test it needs to relinquish the access, and Yippy should act a certain way. This is not so simple, since the app code cannot be interacted with by the testing code (and rightfully so). So what do we do? Well, thankfully from all my experience with interacting with <code>NSPasteboards</code> I realised that I could create a custom pasteboard (not the system wide general pasteboard) to store the current value in; and this worked perfectly. Only the testing code writes to the pasteboard, writing <code>\"true\"</code> or <code>\"false\"</code> at any point in the test and the app reads the value of the pasteboard when it polls for access, implemented by the mock.\n\nThis worked so well, that I’ve done a similar mock for testing the physical key press method is called how and when it should be.\n\nUltimately, I’ve spent a fairly large amount of time wrangling with all this testing but it has been very worthwhile, as I’ve learnt a lot about the app, testing in Xcode, testing in general and writing UI tests, something I’d never done before.",
        "date": 1569828674,
        "author": "Matt Davidson"
    },
    {
        "id": 6,
        "title": "Using NSPasteboard to mock library functions for testing",
        "content": "It is sometimes necessary to mock out library functions for testing when we can't control the value of what is returned but we need to be able to. For example, (for non-Sandbox apps) we can check if the user has given us full control by calling <code>AXIsProcessTrusted()</code>. However, we may need to test our app <code>AXIsProcessTrusted()</code> when both <code>true</code> and <code>false</code> are returned. We may even need to test how our app works if this function starts to return a different value whilst our app is running. This was the case for me in Yippy.\n\nNow it doesn't make much sense for our tests to require us to change the app's actual control during testing, so we need another way. This can be done simply with a mock. Let's see how:\n\nFirst, we need to stop calling <code>AXIsProcessTrusted()</code> directly in our app. We can do this by creating a helper class:\n<p class='Code-block'><span class='Code-keyword'>class</span> AccessControlHelper {\n\n    <span class='Code-keyword'>func</span> isControlGranted() -> <span class='Code-type'>Bool</span> {\n        <span class='Code-keyword'>return</span> <span class='Code-type'>AXIsProcessTrusted</span>()\n    }\n}</p>By some form of <a href='https://www.swiftbysundell.com/articles/different-flavors-of-dependency-injection-in-swift/' target='_blank'>dependency injection</a> <code>AccessControlHelper</code> should be injected into the app globally. Next we create our mock data source for whether the app has been granted full control or not by using a globally accessable <code>NSPasteboard</code>:\n<p class='Code-block'><span class='Code-keyword'>import</span> Cocoa\n\n<span class='Code-keyword'>struct</span> AccessControlMock {\n\n    <span class='Code-keyword'>static let</span> pasteboard = <span class='Code-type'>NSPasteboard</span>(name: <span class='Code-type'>NSPasteboard</span>.<span class='Code-type'>Name</span>(rawValue: <span class='Code-string'>\"Yippy.UITesting.AccessControl\"</span>))\n    \n    <span class='Code-keyword'>static func</span> setControlGranted(_ access: <span class='Code-type'>Bool</span>) {\n        <span class='Code-type'>pasteboard</span>.<span class='Code-type'>declareTypes</span>([.<span class='Code-type'>string</span>], owner: <span class='Code-keyword'>nil</span>)\n        <span class='Code-keyword'>let</span> str = access ? <span class='Code-string'>\"true\"</span> : <span class='Code-string'>\"false\"</span>\n        <span class='Code-type'>pasteboard</span>.<span class='Code-type'>setString</span>(str, forType: .<span class='Code-type'>string</span>)\n    }\n    \n    <span class='Code-keyword'>static func</span> isControlGranted() -> <span class='Code-type'>Bool</span> {\n        <span class='Code-keyword'>return</span> <span class='Code-type'>pasteboard</span>.<span class='Code-type'>string</span>(forType: .<span class='Code-type'>string</span>) == <span class='Code-string'>\"true\"</span>\n}</p>Now when a testing instance of our app is running we can inject the following <code>AccessControlHelperMock</code> in place of <code>AccessControlHelper</code>:<p class='Code-block'><span class='Code-keyword'>class</span> AccessControlHelperMock: <span class='Code-keyword'>AccessControlHelper</span> {\n\n    <span class='Code-keyword'>func</span> isControlGranted() -> <span class='Code-type'>Bool</span> {\n        <span class='Code-keyword'>return</span> <span class='Code-type'>AccessControlMock</span>.<span class='Code-type'>isControlGranted()</span>()\n    }\n}</p>Now finally, in our tests we can 'control' the access control:<p class='Code-block'><span class='Code-comment'>// Start off without control</span>\n<span class='Code-type'>AccessControlMock</span>.<span class='Code-type'>setControlGranted</span>(<span class='Code-keyword'>false</span>)\n\n<span class='Code-comment'>// Prompt the user to provide control</span>\n...\n\n<span class='Code-comment'>// Simulate the user relinquishing control</span>\n<span class='Code-type'>AccessControlMock</span>.<span class='Code-type'>setControlGranted</span>(<span class='Code-keyword'>false</span>)</p>",
        "date": 1569828675,
        "author": "Matt Davidson"
    }
]
